// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:kitshell/src/rust/frb_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_capabilities`, `get_server_information`, `notify`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `NotificationServiceProxy`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `as_mut`, `as_ref`, `builder`, `call_mut`, `call`, `clone`, `clone`, `clone`, `fmt`, `from`, `get_all`, `get`, `inner`, `into_inner`, `introspect_to_writer`, `name`, `serialize`, `set_mut`, `set`, `spawn_tasks_for_methods`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `builder`, `get_capabilities`, `get_server_information`, `inner_mut`, `inner`, `into_inner`, `new`, `notify`

Stream<NotificationData> watchNotificationBus() =>
    RustLib.instance.api.crateApiNotificationsWatchNotificationBus();

Future<void> invokeNotifAction({required int id, required String actionKey}) =>
    RustLib.instance.api.crateApiNotificationsInvokeNotifAction(
      id: id,
      actionKey: actionKey,
    );

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NotificationDbus>>
abstract class NotificationDbus implements RustOpaqueInterface {
  NotificationService get service;

  set service(NotificationService service);
}

class NotificationData {
  const NotificationData({
    required this.id,
    required this.appName,
    required this.replacesId,
    required this.appIcon,
    required this.summary,
    required this.body,
    required this.actions,
    required this.expireTimeout,
    required this.hints,
    required this.addedAt,
  });
  final int id;
  final String appName;
  final int replacesId;
  final String appIcon;
  final String summary;
  final String body;
  final List<String> actions;
  final int expireTimeout;
  final Map<String, String> hints;
  final DateTime addedAt;

  @override
  int get hashCode =>
      id.hashCode ^
      appName.hashCode ^
      replacesId.hashCode ^
      appIcon.hashCode ^
      summary.hashCode ^
      body.hashCode ^
      actions.hashCode ^
      expireTimeout.hashCode ^
      hints.hashCode ^
      addedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NotificationData &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          appName == other.appName &&
          replacesId == other.replacesId &&
          appIcon == other.appIcon &&
          summary == other.summary &&
          body == other.body &&
          actions == other.actions &&
          expireTimeout == other.expireTimeout &&
          hints == other.hints &&
          addedAt == other.addedAt;
}

class NotificationService {
  const NotificationService({
    required this.sink,
  });
  final RustStreamSink<NotificationData> sink;

  @override
  int get hashCode => sink.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NotificationService &&
          runtimeType == other.runtimeType &&
          sink == other.sink;
}
