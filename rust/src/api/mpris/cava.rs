use crate::frb_generated::StreamSink;
use crate::utils::misc::is_program_in_path;
use anyhow::bail;
use anyhow::Error;
use std::ffi::OsStr;
use std::fs::File;
use std::io::BufRead;
use std::io::BufReader;
use std::process::Command;
use std::thread::sleep;
use std::time::Duration;
use std::{fs::OpenOptions, io::Write, path::PathBuf};
use sysinfo::System;

#[derive(Clone)]
pub struct CavaState {
    pub data: [u8; 32],
    pub bar_count: u16,
    pub cava_pid: u32,
}

pub fn listen_to_cava(sink: StreamSink<CavaState>) -> Result<(), Error> {
    let _ = kill_other_cava_instance();

    // Check whether we have Cava on the system
    match is_program_in_path("cava") {
        true => {}
        false => {
            bail!("Cava binary not found on the system!");
        }
    }

    // Generate config file
    let config_file_path = generate_config_file()?;
    println!(
        "API | Cava: Config created on {:?}",
        config_file_path.as_os_str()
    );

    // Spawn CAVA
    let mut handle = match Command::new("cava")
        .arg("-p")
        .arg(config_file_path.as_os_str())
        .spawn()
    {
        Ok(val) => val,
        Err(_) => bail!("API | Cava: Failed to spawn Cava"),
    };
    sleep(Duration::from_millis(1000));
    let pid = &handle.id();

    let mut out_path = PathBuf::new();
    out_path.push(get_temp_dir());
    out_path.push("kitshell-cava-out");

    let file = match File::open(out_path) {
        Ok(val) => val,
        Err(_) => bail!("API |Cava: Cava out file not found!"),
    };
    file.lock()?;

    let reader = BufReader::new(&file);
    let mut buffer: [u8; 32] = [0; 32]; // Because cava is set up to 32 bars, we use u8*32 bytes buffer

    for line in reader.lines() {
        match line {
            Ok(val) => {
                let splitted: Vec<&str> = val.split(';').collect();

                for i in 0..splitted.len() {
                    if i >= 32 {
                        break;
                    }
                    let parsed = match splitted[i].parse::<u8>() {
                        Ok(val) => val,
                        Err(_) => 0,
                    };
                    buffer[i] = parsed;
                }
            }
            Err(_) => bail!("API | Cava: failed to read lines"),
        }

        let _ = sink.add(CavaState {
            data: buffer,
            bar_count: 32,
            cava_pid: pid.clone(),
        });
    }

    file.unlock()?;
    handle.kill()?;

    Ok(())
}

fn kill_other_cava_instance() -> Result<(), Error> {
    let sys = System::new_all();
    let mut tmp_path = PathBuf::new();
    tmp_path.push(get_temp_dir());
    tmp_path.push("kitshell-cava-config");

    let mut comparator = String::from("cava -p ");
    comparator.push_str(tmp_path.to_str().unwrap());

    for (_, process) in sys.processes() {
        let cmdline = process.cmd().join(OsStr::new(" "));
        let cmdline_str = cmdline.to_str().unwrap();

        if comparator == cmdline_str {
            println!("API | Cava: Same instace killed");
            process.kill();
        }
    }

    Ok(())
}

/// Generate cava config file and put it on /tmp/
/// Returns the path to generated config
fn generate_config_file() -> Result<PathBuf, Error> {
    let config_file_content = "
## Configuration file for CAVA generated by Kitshell.
## Do NOT modify by hand, it can cause unpredictable behavior on Kitshell
## This config does not touch your original CAVA config.

[general]
framerate = 30
autosens = 1
sensitivity = 80
bars = 32
lower_cutoff_freq = 60
higher_cutoff_freq = 8000
sleep_timer = 5

[input]
method = pipewire
source = auto
channels = 2
active = 0
remix = 0
virtual = 0

[output]
method = raw
channels = mono
raw_target = /tmp/kitshell-cava-out
data_format = ascii
ascii_max_range = 255
bar_delimiter = 59
frame_delimiter = 10
waveform = 0

[smoothing]
monstercat = 1
waves = 0
noise_reduction = 20
    ";

    // Get temporary path
    let mut tmp_path = PathBuf::new();
    tmp_path.push(get_temp_dir());
    tmp_path.push("kitshell-cava-config");
    println!("API | Cava: Creating config on {:?}", tmp_path.as_os_str());

    // Write file
    let mut file = OpenOptions::new()
        .write(true)
        .create(true)
        .open(&tmp_path)?;
    match file.write(config_file_content.as_bytes()) {
        Ok(_) => (),
        Err(e) => bail!(e),
    }
    match file.flush() {
        Ok(val) => val,
        Err(e) => bail!(e),
    }

    Ok(tmp_path)
}

fn get_temp_dir() -> String {
    String::from("/tmp")
}
